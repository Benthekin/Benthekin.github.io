<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Minecraft-like Game with Jumping and Infinite Terrain</title>
  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Basic Three.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting setup
    const ambientLight = new THREE.AmbientLight(0x404040);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 7.5).normalize();
    scene.add(ambientLight);
    scene.add(directionalLight);

    // Player variables
    let playerVelocity = { x: 0, y: 0, z: 0 };
    const gravity = -0.02;
    let isOnGround = false;

    // Camera position and controls
    camera.position.set(0, 5, 10);
    camera.lookAt(0, 0, 0);

    // Terrain generation parameters
    const terrainSize = 16;
    const chunkHeight = 5;
    const loadedChunks = new Set();

    // Function to create blocks
    function createBlock(x, y, z, color) {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshLambertMaterial({ color });
      const block = new THREE.Mesh(geometry, material);
      block.position.set(x, y, z);
      scene.add(block);
      return block;
    }

    // Function to generate terrain
    function generateTerrain(xStart, zStart) {
      const chunkKey = `${xStart},${zStart}`;
      if (loadedChunks.has(chunkKey)) return;

      for (let x = 0; x < terrainSize; x++) {
        for (let z = 0; z < terrainSize; z++) {
          const height = Math.floor(Math.random() * chunkHeight);
          for (let y = 0; y <= height; y++) {
            createBlock(x + xStart, y, z + zStart, y === height ? 0x228B22 : 0x8B4513); // Grass on top, dirt below
          }
        }
      }
      loadedChunks.add(chunkKey);
    }

    // Player movement and jumping
    const keys = {};
    window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

    function updateMovement() {
      const speed = 0.2;

      if (keys['w']) camera.position.z -= speed;
      if (keys['s']) camera.position.z += speed;
      if (keys['a']) camera.position.x -= speed;
      if (keys['d']) camera.position.x += speed;
      
      if (keys[' ']) {  // Jumping
        if (isOnGround) {
          playerVelocity.y = 0.5;  // Jump impulse
          isOnGround = false;
        }
      }
      playerVelocity.y += gravity;  // Apply gravity
      camera.position.y += playerVelocity.y;

      // Check for ground collision
      if (camera.position.y < 5) {
        camera.position.y = 5;
        playerVelocity.y = 0;
        isOnGround = true;
      }
    }

    // Infinite terrain loading based on player position
    function updateTerrain() {
      const playerChunkX = Math.floor(camera.position.x / terrainSize) * terrainSize;
      const playerChunkZ = Math.floor(camera.position.z / terrainSize) * terrainSize;
      generateTerrain(playerChunkX, playerChunkZ);
      generateTerrain(playerChunkX - terrainSize, playerChunkZ);
      generateTerrain(playerChunkX + terrainSize, playerChunkZ);
      generateTerrain(playerChunkX, playerChunkZ - terrainSize);
      generateTerrain(playerChunkX, playerChunkZ + terrainSize);
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      updateMovement();
      updateTerrain();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
