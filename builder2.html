<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft-like Game with Joystick, Mobs, Biomes, and Infinite Terrain</title>
  <style>
    body { margin: 0; overflow: hidden; touch-action: none; }
    canvas { display: block; }

    /* Joystick styling */
    .joystick-container {
      position: fixed;
      left: 20px;
      bottom: 20px;
      width: 100px;
      height: 100px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .joystick {
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      cursor: pointer;
    }

    /* Button styling */
    .button-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .button {
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 5px;
      text-align: center;
      line-height: 50px;
      font-size: 24px;
      cursor: pointer;
    }

    /* Inventory styling */
    .inventory {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px;
      border-radius: 5px;
    }
    .block-btn {
      width: 40px;
      height: 40px;
      margin: 0 5px;
      cursor: pointer;
      border: 1px solid #fff;
    }
    .selected {
      border: 3px solid yellow;
    }
    .delete-btn {
      color: red;
      font-size: 24px;
      font-weight: bold;
      line-height: 40px;
      text-align: center;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- Joystick -->
  <div class="joystick-container" id="joystickContainer">
    <div class="joystick" id="joystick"></div>
  </div>

  <!-- Buttons for actions -->
  <div class="button-container">
    <div class="button" id="placeButton">⬆️</div>
    <div class="button" id="breakButton">⬇️</div>
  </div>

  <!-- Inventory for tools -->
  <div class="inventory" id="inventory"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Scene, Camera, Renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // Sun light
    directionalLight.position.set(5, 10, 7.5).normalize();
    scene.add(directionalLight);

    // Camera position
    camera.position.set(0, 20, 30);
    camera.lookAt(0, 0, 0);

    // Inventory setup
    const blockTypes = [
      { color: 0x00ff00, name: 'Grass' },
      { color: 0x8B4513, name: 'Dirt' },
      { color: 0x808080, name: 'Stone' },
      { color: 0xffd700, name: 'Sand' },
      { color: 0x87ceeb, name: 'Water' },
      { deleteTool: true, name: 'Delete Tool' } // Red X delete tool
    ];
    let selectedBlockType = blockTypes[0]; // Default is grass

    // Inventory creation
    const inventoryContainer = document.getElementById('inventory');
    blockTypes.forEach((block, index) => {
      const button = document.createElement('div');
      button.classList.add('block-btn');
      if (block.deleteTool) {
        button.classList.add('delete-btn');
        button.innerHTML = 'X'; // Red X delete button
      } else {
        button.style.backgroundColor = `#${block.color.toString(16).padStart(6, '0')}`;
      }
      if (index === 0) button.classList.add('selected'); // Highlight default
      button.addEventListener('click', () => {
        document.querySelectorAll('.block-btn').forEach(btn => btn.classList.remove('selected'));
        button.classList.add('selected');
        selectedBlockType = block;
      });
      inventoryContainer.appendChild(button);
    });

    // Joystick controls
    const joystickContainer = document.getElementById("joystickContainer");
    const joystick = document.getElementById("joystick");
    let joystickPosition = { x: 0, y: 0 };
    let isJoystickActive = false;

    joystick.addEventListener("touchstart", (e) => {
      e.preventDefault();
      isJoystickActive = true;
      const touch = e.touches[0];
      joystickPosition.x = touch.clientX - joystickContainer.offsetLeft;
      joystickPosition.y = touch.clientY - joystickContainer.offsetTop;
    });

    joystick.addEventListener("touchmove", (e) => {
      if (isJoystickActive) {
        const touch = e.touches[0];
        joystickPosition.x = touch.clientX - joystickContainer.offsetLeft;
        joystickPosition.y = touch.clientY - joystickContainer.offsetTop;
        joystick.style.transform = `translate(${joystickPosition.x - 25}px, ${joystickPosition.y - 25}px)`;
      }
    });

    joystick.addEventListener("touchend", () => {
      isJoystickActive = false;
      joystick.style.transform = 'translate(0, 0)';
    });

    // Handle movement based on joystick position
    function updateMovement() {
      if (isJoystickActive) {
        let xMove = (joystickPosition.x - 50) / 50;
        let zMove = (joystickPosition.y - 50) / 50;

        camera.position.x += xMove;
        camera.position.z += zMove;

        // Keep the player within bounds
        camera.position.x = Math.max(Math.min(camera.position.x, 20), -20);
        camera.position.z = Math.max(Math.min(camera.position.z, 20), -20);
      }
    }

    // Infinite terrain generation with complex biomes
    const chunkSize = 16;
    const chunkHeight = 5;
    const loadedChunks = new Map();

    function getBiome(x, z) {
      if (z < 0) return 'snow';
      if (x < 0) return 'sand';
      return 'grass';
    }

    // More complex biome generation with trees, sand, and snow
    function generateTerrain(xStart, zStart) {
      const chunkKey = `${xStart},${zStart}`;
      if (loadedChunks.has(chunkKey)) return; // Avoid regenerating

      for (let x = xStart; x < xStart + chunkSize; x++) {
        for (let z = zStart; z < zStart + chunkSize; z++) {
          const biome = getBiome(x, z);
          let height = Math.floor(Math.random() * chunkHeight);
          for (let y = 0; y <= height; y++) {
            createBlock(x, y, z, getBiomeColor(biome));
            if (biome === 'grass' && y === height) createTree(x, y + 1, z); // Add tree to grass biome
            if (biome === 'sand' && y === height) createBush(x, y + 1, z); // Add bushes to sand biome
          }
        }
      }

      loadedChunks.set(chunkKey, true); // Mark chunk as loaded
    }

    // Helper functions for generating blocks and items
    function createBlock(x, y, z, color) {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshLambertMaterial({ color });
      const block = new THREE.Mesh(geometry, material);
      block.position.set(x, y, z);
      scene.add(block);
    }

    function getBiomeColor(biome) {
      switch (biome) {
        case 'sand': return 0xFFFF00;
        case 'grass': return 0x228B22;
        case 'snow': return 0xFFFFFF;
      }
    }

    function createTree(x, y, z) {
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.3, 0.3, 2),
        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
      );
      trunk.position.set(x, y, z);
      scene.add(trunk);
      const leaves = new THREE.Mesh(
        new THREE.SphereGeometry(1, 8, 8),
        new THREE.MeshLambertMaterial({ color: 0x228B22 })
      );
      leaves.position.set(x, y + 1.5, z);
      scene.add(leaves);
    }

    function createBush(x, y, z) {
      const bush = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 8, 8),
        new THREE.MeshLambertMaterial({ color: 0x32cd32 })
      );
      bush.position.set(x, y, z);
      scene.add(bush);
    }

    // Day-night cycle logic
    let time = 0; // Time in the cycle (0 to 1)
    const dayLength = 1000; // Duration of a full day in milliseconds

    function updateDayNightCycle() {
      time += 1 / dayLength; // Increment time
      if (time > 1) time = 0; // Reset after one cycle

      // Adjust light intensity based on the time of day
      directionalLight.intensity = Math.max(0, Math.cos(time * Math.PI * 2));
      ambientLight.intensity = Math.min(1, Math.sin(time * Math.PI * 2));

      // Adjust sky color
      const skyColor = new THREE.Color(0x87ceeb); // Blue sky
      skyColor.lerp(new THREE.Color(0x2c3e50), Math.sin(time * Math.PI)); // Dark blue at night
      scene.background = skyColor;
    }

    function animate() {
      requestAnimationFrame(animate);
      updateMovement();
      generateTerrain(Math.floor(camera.position.x / chunkSize) * chunkSize, Math.floor(camera.position.z / chunkSize) * chunkSize);
      updateDayNightCycle();
      renderer.render(scene, camera);
    }

    animate();

    // Resize handling
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
