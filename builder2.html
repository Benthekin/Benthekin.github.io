<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced Minecraft-like Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    
    /* UI Styles */
    #joystick-container {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 100px;
      height: 100px;
      background: rgba(200, 200, 200, 0.5);
      border-radius: 50%;
      touch-action: none;
    }
    #inventory {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 5px;
    }
    .inventory-item {
      width: 50px;
      height: 50px;
      background-color: lightgray;
      border: 2px solid black;
      cursor: pointer;
    }
    #jump-button {
      position: fixed;
      bottom: 100px;
      left: 60px;
      width: 80px;
      height: 80px;
      background-color: orange;
      border-radius: 50%;
      text-align: center;
      line-height: 80px;
      color: white;
      font-size: 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="joystick-container"></div>
  <div id="jump-button">Jump</div>
  <div id="inventory"></div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Basic Three.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting setup
    const ambientLight = new THREE.AmbientLight(0x404040);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 7.5).normalize();
    scene.add(ambientLight);
    scene.add(directionalLight);

    // Inventory setup
    const inventoryContainer = document.getElementById('inventory');
    const blockTypes = [
      { color: 0x228B22, name: "grass" },
      { color: 0x8B4513, name: "dirt" },
      { color: 0xFFFFFF, name: "snow" },
      { color: 0xFF0000, name: "delete" }, // Red X for delete tool
      { color: 0x8B0000, name: "wood" },
      { color: 0xFFFF00, name: "stone" }
    ];
    let selectedBlockType = blockTypes[0];

    blockTypes.forEach((block, index) => {
      const item = document.createElement('div');
      item.className = 'inventory-item';
      item.style.backgroundColor = `#${block.color.toString(16)}`;
      item.onclick = () => selectBlock(index);
      inventoryContainer.appendChild(item);
    });

    function selectBlock(index) {
      selectedBlockType = blockTypes[index];
    }

    // Joystick setup
    const joystick = document.getElementById('joystick-container');
    let joystickOffset = { x: 0, y: 0 };
    let isDragging = false;

    joystick.addEventListener('pointerdown', () => isDragging = true);
    window.addEventListener('pointerup', () => { isDragging = false; joystickOffset = { x: 0, y: 0 }; });
    window.addEventListener('pointermove', (event) => {
      if (!isDragging) return;
      joystickOffset = { x: event.clientX - 50, y: event.clientY - 50 };
    });

    // Jump button
    const jumpButton = document.getElementById('jump-button');
    let jumpVelocity = 0;
    let isOnGround = false;
    jumpButton.addEventListener('pointerdown', () => {
      if (isOnGround) jumpVelocity = 0.5; // Jump impulse
      isOnGround = false;
    });

    // Camera rotation (mimicking Minecraft Pocket Edition)
    let cameraRotation = { x: 0, y: 0 };
    const rotationSpeed = 0.002;
    window.addEventListener('pointermove', (event) => {
      if (event.buttons === 1) {
        cameraRotation.x -= event.movementY * rotationSpeed;
        cameraRotation.y -= event.movementX * rotationSpeed;
        camera.rotation.set(cameraRotation.x, cameraRotation.y, 0);
      }
    });

    // Player movement
    function updateMovement() {
      const speed = 0.1;
      camera.position.x += joystickOffset.x * speed * 0.01;
      camera.position.z += joystickOffset.y * speed * 0.01;

      jumpVelocity += -0.02;  // Gravity
      camera.position.y += jumpVelocity;
      if (camera.position.y < 5) { camera.position.y = 5; jumpVelocity = 0; isOnGround = true; }
    }

    // Block breaking mechanism
    function breakBlockAt(x, y, z) {
      const raycaster = new THREE.Raycaster();
      raycaster.ray.origin.set(camera.position.x, camera.position.y, camera.position.z);
      raycaster.ray.direction.set(x - camera.position.x, y - camera.position.y, z - camera.position.z);
      
      const intersects = raycaster.intersectObjects(scene.children);
      if (intersects.length > 0) {
        const block = intersects[0].object;
        scene.remove(block);
      }
    }

    // Block placing
    function placeBlockAt(x, y, z, color) {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshLambertMaterial({ color });
      const block = new THREE.Mesh(geometry, material);
      block.position.set(x, y, z);
      scene.add(block);
    }

    // Terrain generation and chunk management
    const terrainSize = 16;
    const chunkHeight = 5;
    const loadedChunks = new Set();

    function generateTerrain(xStart, zStart) {
      const chunkKey = `${xStart},${zStart}`;
      if (loadedChunks.has(chunkKey)) return;

      for (let x = 0; x < terrainSize; x++) {
        for (let z = 0; z < terrainSize; z++) {
          const height = Math.floor(Math.random() * chunkHeight);
          for (let y = 0; y <= height; y++) {
            createBlock(x + xStart, y, z + zStart, y === height ? 0x228B22 : 0x8B4513); // Grass on top, dirt below
          }
        }
      }
      loadedChunks.add(chunkKey);
    }

    // Infinite terrain loading
    function updateTerrain() {
      const playerChunkX = Math.floor(camera.position.x / terrainSize) * terrainSize;
      const playerChunkZ = Math.floor(camera.position.z / terrainSize) * terrainSize;
      generateTerrain(playerChunkX, playerChunkZ);
      generateTerrain(playerChunkX - terrainSize, playerChunkZ);
      generateTerrain(playerChunkX + terrainSize, playerChunkZ);
      generateTerrain(playerChunkX, playerChunkZ - terrainSize);
      generateTerrain(playerChunkX, playerChunkZ + terrainSize);
    }

    // Mobs: Simple entities that move around randomly
    function spawnMobs() {
      const mobCount = 3; // Number of mobs to spawn
      for (let i = 0; i < mobCount; i++) {
        const mobGeometry = new THREE.SphereGeometry(0.5, 8, 8);
        const mobMaterial = new THREE.MeshLambertMaterial({ color: 0x00FF00 });
        const mob = new THREE.Mesh(mobGeometry, mobMaterial);
        mob.position.set(Math.random() * 100 - 50, 1, Math.random() * 100 - 50);
        scene.add(mob);
      }
    }

    // Main animation loop
    function animate() {
      updateMovement();
      updateTerrain();
      spawnMobs();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Initial camera position and start animation
    camera.position.set(0, 5, 10);
    camera.lookAt(0, 5, 0);
    animate();

  </script>
</body>
</html>
