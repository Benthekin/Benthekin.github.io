<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Infinite Terrain with Day-Night Cycle</title>
  <style>
    body { margin: 0; overflow: hidden; touch-action: none; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
  <script>
    // Scene, Camera, Renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040); // Base light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // Sunlight
    directionalLight.position.set(10, 50, 30);
    scene.add(ambientLight);
    scene.add(directionalLight);

    // Day-Night cycle variables
    let time = 0; // Time counter for the day-night cycle
    const cycleSpeed = 0.002; // Adjust for slower cycles

    // Perlin noise instance for terrain generation
    const simplex = new SimplexNoise();

    // Terrain generation parameters
    const chunkSize = 16; // Number of blocks per chunk side
    const blockSize = 1; // Size of each block
    const loadedChunks = new Map(); // Track loaded chunks

    // Helper function to create a block
    function createBlock(x, y, z, color) {
      const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
      const material = new THREE.MeshStandardMaterial({ color });
      const block = new THREE.Mesh(geometry, material);
      block.position.set(x, y, z);
      scene.add(block);
    }

    // Generate terrain chunk at specific position
    function generateChunk(xStart, zStart) {
      const chunkKey = `${xStart},${zStart}`;
      if (loadedChunks.has(chunkKey)) return; // Avoid regenerating chunks

      for (let x = 0; x < chunkSize; x++) {
        for (let z = 0; z < chunkSize; z++) {
          // Calculate height using Perlin noise
          const worldX = xStart + x;
          const worldZ = zStart + z;
          const height = Math.floor(simplex.noise2D(worldX / 10, worldZ / 10) * 5 + 5); // Adjust scaling

          // Create blocks up to the calculated height
          for (let y = 0; y <= height; y++) {
            const color = y === height ? 0x228B22 : 0x8B4513; // Top block green, others brown
            createBlock(worldX * blockSize, y * blockSize, worldZ * blockSize, color);
          }
        }
      }

      loadedChunks.set(chunkKey, true); // Mark the chunk as loaded
    }

    // Player position tracking for infinite terrain
    function loadChunksAroundPlayer() {
      const playerChunkX = Math.floor(camera.position.x / (chunkSize * blockSize)) * chunkSize;
      const playerChunkZ = Math.floor(camera.position.z / (chunkSize * blockSize)) * chunkSize;

      // Load chunks around the player in a 3x3 grid
      for (let dx = -chunkSize; dx <= chunkSize; dx += chunkSize) {
        for (let dz = -chunkSize; dz <= chunkSize; dz += chunkSize) {
          generateChunk(playerChunkX + dx, playerChunkZ + dz);
        }
      }
    }

    // Day-Night cycle logic
    function updateDayNightCycle() {
      time += cycleSpeed;
      const intensity = (Math.sin(time) + 1.5) / 2.5; // Smooth intensity variation
      ambientLight.intensity = 0.2 + intensity * 0.5; // Vary ambient light
      directionalLight.intensity = intensity;

      // Adjust color to simulate sunrise/sunset hues
      const colorValue = new THREE.Color(`hsl(${(time * 30) % 360}, 100%, ${50 + intensity * 30}%)`);
      directionalLight.color.set(colorValue);
    }

    // Render loop
    function animate() {
      requestAnimationFrame(animate);
      loadChunksAroundPlayer();
      updateDayNightCycle();
      renderer.render(scene, camera);
    }

    // Initial camera setup
    camera.position.set(0, 10, 20);
    camera.lookAt(0, 0, 0);

    // Resize handling
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate(); // Start the game loop
  </script>
</body>
</html>
